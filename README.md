# bmstu_falp
Functional and logical programming 2021/2022 course

# **Важная теоретическая информация по курсу**

> "Работа компьютера - пошаговое изменение состояния вычисления(памяти). Наличие оператора присваивания явяется подтверждением того, что язык императивный." Любое s-выражение по умолчанию воспринимается как программа.
> Лисп написан на лиспе. Лисп использует указатели, а не ссылки. Лисп - расширяемый язык. Всегда возвращается последнее вычисленное значение.
 
 Lisp опирается на лямбда-исчисления Черча. Lisp предложил символьную обработку данных, а не числовую, основываясь на том, что программа - это набор символов(текст). Все можно представить в виде функции или композиции функций (принцип конструирования программ). 
 
 Нет разделения на код и данные. Lisp - интерпретатор. В Lisp нет переменных. "Нет типизации - не надо ничего описывать." Доступ через указатели. Понятие типа связано с объем выделяемой памяти. Lisp сам распределяет память. 2 варианта представления в памяти: блок памяти с 5 указателями или бинарный узел.
 
 Вся информация (код и данные) в Lisp представляется в виде **S-выражений**  = <атом>|<точечная пара>. 
 
 **Базис** Lisp (минимальный набор конструкций язка и структур данных, позволяющий решить любую задачу) образуют: 
* Атом - (элементарная конструкция языка) может обозначать абсолютно любой объект. Может быть представлен как:
  + Символ (идентификаторы) - набор литер, начинающихся с буквы;
  + Специальный символ -  T, Nil (логические константы);
  + Самоопределимый атом - натуральные, дробные, вещественные числа, строки.
* Структура - 
  + Точечная пара = (<атом>.<атом>)|(<атом>.<точечная пара>)|(<точечная пара>.<атом>)|(<точечная пара>.>точечная пара>);
  + Список = <пустой список>|<непустой список>, где <пустой список> = ()|Nil, <непустой список> = <первый элемент>.<хвост>, <первый элемент> = <S-выражение>, <хвост> = <список>.
* Базовые функции;
* Базовые функционалы.

Программы, написанные на Lisp, представляются в виде списков! Это дает возможность генерировать т.н. Lisp-код, что дает разработчику возможность создавать программы, которые пишут программы. Чтобы Lisp не счёл список за вызов функции, его нужно цитировать. В противном случае список будет рассмотрен как код.

![Image alt](materials/pic_01.png)

Атом в памяти представляется 5 указателями:
* Name;
* Value;
* Function;
* Properties;
* Package.

Классификация функций:
* Чистые (так, как принято в математике, вычисляются *все* аргументы);
* Рекурсивные (организовывают повторные вычисления);
* Специальные или формы - переменное кол-во аргументов или они обрабатываются по-разному, могут вычисляться не все. Входят cond, if, and, or, quote, eval, lambda (анонимные функции, базовый способ опр. функций). Важно помнить про порядок вычисления. Не всегда аргумент может вычисляться => его нет в памяти => при попытке доступа возникнет ошибка;
* Псевдофункции - создают эффекты на экране и тд;
* Функции с вариантами значений;
* Функционалы - в качестве аргументов принимают функции или возвращают функцию (позволяют создавать синтаксически управляемые программы). К ним относятся базовые функции apply, funcall;
* Базисные функции - car, cdr, cons, atom, and, or;
* Функции частичного характера - некорректно обрабатывает некоторые типы аргмуентов.

Классификация базисных функций:
* Селекторы - car, cdr;
* Функции-конструкторы:
  + cons - создает списковую ячейку и расставляет указатели, передается 2 S-выражения;
  + list - (не базисная форма) создает столько списковых ячеек, сколько аргументов, менее эффективная;
* Предикаты:
  + null - пустая ли структура;
  + listp - список или нет;
  + consp - представлена ли структура в виде списковых ячеек;
  + eq - сравнивает указатели на символьные атомы, не сравнивает числа;
  + eql - сравнивает атомы и числа одного типа (= применима только к числам, любого типа), не сравнивает списки, часто исп. в других функциях;
  + equal - eql + списки, но не сравнивает числа разных типов (2 и 2.0);
  + equalp - сравнивает всё.

Функции, реализующие работу со списком:
* Разрушающие структуру - не меняют исходный список, только формируют результа;
* Не разрушающие структуру - меняют состояние списка.

Рекурсивные функции:
* Простая - вызов 1 раз в теле;
* I порядка - несколько раз;
* Взаимная - вызывают друг друга;
* Дополнительная.

В связи с этим есть дубли функций: одна разрущает, другая нет.

**Append**(не разр.): функция объединения списков, работает с копией всех аргументов, кроме последнего. Cdr-указателями они сцепляются. Засчет этого сохраняется возможность работы со всеми списками-аргументами и списком-результатом. Засчет экономии могут возникнуть опасности, т.к. можно работать с дублями и все поменяется.
Дубль append: ncone (префикс n - не создает дубли) просто переставляет указатели.

Все стандартные функции работают по первому уровню вложенности.

Функции в Lisp *всегда* имеют результат. Аргументы и результат - S-выражения.

**Способы определения функций**: лямбда-выражение = (lambda λ-список формы). Вызов: (λ-выражение последовательность форм).

Использование функций с именем: defun. Связывает символьный атом (имя функции) с лямбда-определением. При повторных вычислениях эффективнее использовать лямбда-поределения, т.к. не дергается указатель.

>Задать значение аргументу (присвоить) ~ передать формальный параметр на место фактического.

Функция **let** - аналог лямбда-определения, только связывание формальных параметров с фактическими вынесено в начало.

(let ((x1 p1) (x2 p2) ...) форма) = ((lambda (x1 x2 ...) форма) p1 p2 ...).

Атомы: локальные и глобальные. Можно закрепить значение символьного атома: setf (не вычисляет 1 аргумент) / setq (вычисляет аргумент и устанавливает указатель value). Способ организации глобального атома.

Ассоциативные таблицы: список точечных пар <ключ.значение> (простой вариант) (assoc - вернуть ключ по значению, rassoc - вернуть значение по ключу).

Организация повторных вычислений: функционалы или рекурсия.

Функционалы: применяющие (apply, funcall) и отображающие. Функциональная блокировка: фиксация текущих значений глобальных переменных (окружение состояния памяти).
Отображающие: организация повторных вычислений. (mapcar #'fun lst), (maplist #'fun lst). Дубли mapcan и mapcon, обхединяют результат с помощью ncone, структуроразрушающие. Функция применяется к каждому элементу списка. На выходе список.

(maplist #’fun lst1 lst2 lstk). Mapcar не контролирует длину списков. Прекращает работу, когда заканчивается кратчайший список. Fun должна быть k-аргументной.

(reduce #'fun lst) - применяет функцию каскадно, т.е. применение функции к аргументам, к результату и т.д.

**Список->множество:**

(defun consist-of (lst)
	(if (member (car lst) (cdr lst))1 0))

(defun all-last-element (lst)
	(if (eql (consist-of lst) 0)(list (car lst))()))

(defun collection-to-set (lst)
	(mapcon #'al-last-element lst))

(collection-to-set '(i t i g t k s i f k)) ;; (g t s i f k)

> Рекурсия = ссылка на описываемый объект при определении этого объекта.

Аспекты, о которых нужно думать при написании рекурсивных функций: как выйти из рекурсии? как войти? как запустить 1-ый раз?

Хвостовая рекурсия - рекурсия, при завершении которой результат УЖЕ сформирован, не отстается отложенных вычислений. 

Общий вид хвостовой рекурсии:

```
(defun fun (x)
	(cond ((end-test) end-value)
	       (t (fun changed-x))))
```

PROLOG

> Аппетит приходит во время еды. 

> Прорыв в сфере вычислений происходит после прорыва в сфере элементной базы.

> Нельзя ли пприспособить технику, чтобы с ее помощью доказывать теоремы?

Prolog работает со знаниями. Как их зафиксировать и как обрабатывать? Prolog обрабатывает символьные выражения.

Как работает математическая логика(базис prolog)? Чем оперирует? Она нужна, чтобы фиксировать логические рассуждения человека.

Высказывание - обозначается латинской буквой. Повествовательное предложение, о котором можно сказать, истинно оно или нет. В каком-то смысле оно логическая константа.

Базисные операции: конъюнкия, дизъюнкция, отрицание.

Логическая функция - предикат. Тавтология - абсолютная истина(закон).

Аксиома (факт) - предположение, которое считается истинным, до момента, пока оно не будет опровергнуто. Теория строится, опираясь на аксиомы.

Пра́вило резолю́ций — это правило вывода, восходящее к методу доказательства теорем через поиск противоречий.

Программа не должна фиксировать порядок действий. Это основополагающее свойство. Например, одна группа людей может сейчас думтаь об одном и том же, но вероятность того, что следующая их мысль совпадет, мала. Пролог поддерживает декларативный (описывающий предметную область) способ программирования.

Программа на прологе представляет собой базу знаний, состояющую из фактов (аксиом) и правил (теорем), и вопрос. Только 2 варианта предложений - либо факт, либо правило. Утверждения должны быть истинными. 

Раздел clauses: содержит предложения (знания), заканчивающиеся точкой.
Раздел goal: вопрос. Ответ на вопрос - либо да, либо нет. А как?

В прологе используется единственная конструкция, называющаяся термом - это константа (символьный атом) или переменная или составной терм.
Зачем используется символьная константа? Для обозначения объекта или процесса предметной области. Комбинация символов, начинающая с маленькой буквы.

Переменная - (обозначаются с большой буквы или с символа подчеркивания) способ повышения уровня абстракции. Переменные могут быть именованными и анонимными. Все анонимные переменные обозначаются одинаково - _.

Переменная - передача данных во времени и пространстве.

Составной терм используется для фиксации обозначения связи между объектами. f(t1, t2, ..., tn). f - функциональный символ или главный функтор, это название отношения. Главный - потому что внутри тоже могут быть функторы. ti - термы.

```
student(ivanov, mgtu) ;Один конкретный студент из мгту
student(X, mgtu)      ;Выше абстракция, все студенты из мгту
student(ivanov)       ;Это совершенно другое утверждение, арность разная.
```

На первом месте позиционно указывается студент, хотя системе все равно. Порядок не фиксирован, пока он не указан первый раз. И дальше система будет позиционно первые аргументы как объекты одной природы, вторые - другой, а может быть такой же, и тд.

Во время формулировки переменная не имеет значения вообще.

Процесс работы программы - каким-то образом подобрать значение переменной и принять решение да или нет. Это конкретизация. Система ведет доказательство методом проб и ошибок.

Общая форма правила: A: - B1, B2, ..., Bn; A, Bi - термы. А - заголовок правила (фиксация (формулировка) знания о том, что между аргументами возможна истинная связь), Bi - тело (условие истинности). Это предложение.

Факты, не содержащие переменные, называются основными.
