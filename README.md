# bmstu_falp
Functional and logical programming 2021/2022 course

# **Важная теоретическая информация по курсу**

> "Работа компьютера - пошаговое изменение состояния вычисления(памяти). Наличие оператора присваивания явяется подтверждением того, что язык императивный." Любое s-выражение по умолчанию воспринимается как программа.
> Лисп написан на лиспе. Лисп использует указатели, а не ссылки. Лисп - расширяемый язык. Всегда возвращается последнее вычисленное значение.
 
 Lisp опирается на лямбда-исчисления Черча. Lisp предложил символьную обработку данных, а не числовую, основываясь на том, что программа - это набор символов(текст). Все можно представить в виде функции или композиции функций (принцип конструирования программ). 
 
 Нет разделения на код и данные. Lisp - интерпретатор. В Lisp нет переменных. "Нет типизации - не надо ничего описывать." Доступ через указатели. Понятие типа связано с объем выделяемой памяти. Lisp сам распределяет память. 2 варианта представления в памяти: ячейка или бинарный узел.
 
 Вся информация (код и данные) в Lisp представляется в виде **S-выражений**  = <атом>|<точечная пара>. 
 
 **Базис** Lisp (минимальный набор конструкций язка и структур данных, позволяющий решить любую задачу) образуют: 
* Атом - (элементарная конструкция языка) может обозначать абсолютно любой объект. Может быть представлен как:
  + Символ (идентификаторы) - набор литер, начинающихся с буквы;
  + Специальный символ -  T, Nil (логические константы);
  + Самоопределимый атом - натуральные, дробные, вещественные числа, строки.
* Структура - 
  + Точечная пара = (<атом>.<атом>)|(<атом>.<точечная пара>)|(<точечная пара>.<атом>)|(<точечная пара>.>точечная пара>);
  + Список = <пустой список>|<непустой список>, где <пустой список> = ()|Nil, <непустой список> = <первый элемент>.<хвост>, <первый элемент> = <S-выражение>, <хвост> = <список>.
* Базовые функции;
* Базовые функционалы.

Программы, написанные на Lisp, представляются в виде списков! Это дает возможность генерировать т.н. Lisp-код, что дает разработчику возможность создавать программы, которые пишут программы. Чтобы Lisp не счёл список за вызов функции, его нужно цитировать. В противном случае список будет рассмотрен как код.

![Image alt](materials/pic_01.png)

Атом в памяти представляется 5 указателями:
* Name;
* Value;
* Function;
* Properties;
* Package.

Классификация функций:
* Чистые (так, как принято в математике, вычисляются *все* аргументы);
* Рекурсивные (организовывают повторные вычисления);
* Специальные или формы - переменное кол-во аргументов или они обрабатываются по-разному, могут вычисляться не все. Входят cond, quote, eval, lambda (анонимные функции, базовый способ опр. функций);
* Псевдофункции - создают эффекты на экране и тд;
* Функции с вариантами значений;
* Функционалы - в качестве аргументов принимают функции или возвращают функцию (позволяют создавать синтаксически управляемые программы). К ним относятся базовые функции apply, funcall;
* Базисные функции - car, cdr, cons, atom, and, or;
* Функции частичного характера - некорректно обрабатывает некоторые типы аргмуентов.

Классификация базисных функций:
* Селекторы - car, cdr;
* Функции-конструкторы:
  + cons - создает списковую ячейку и расставляет указатели, передается 2 S-выражения;
  + list - (не базисная форма) создает столько списковых ячеек, сколько аргументов, менее эффективная;
* Предикаты:
  + null - пустая ли структура;
  + listp - список или нет;
  + consp - представлена ли структура в виде списковых ячеек;
  + eq - сравнивает указатели на символьные атомы, не сравнивает числа;
  + eql - сравнивает атомы и числа одного типа (= применима только к числам, любого типа), не сравнивает списки, часто исп. в других функциях;
  + equal - eql + списки, но не сравнивает числа разных типов (2 и 2.0);
  + equalp - сравнивает всё.

Функции в Lisp *всегда* имеют результат. Аргументы и результат - S-выражения.

**Способы определения функций**: лямбда-выражение = (lambda λ-список формы). Вызов: (λ-выражение последовательность форм).

Использование функций с именем: defun. Связывает символьный атом (имя функции) с лямбда-определением. При повторных вычислениях эффективнее использовать лямбда-поределения, т.к. не дергается указатель.

>Задать значение аргументу (присвоить) ~ передать формальный параметр на место фактического.

Функция **let** - аналог лямбда-определения, только связывание формальных параметров с фактическими вынесено в начало.

(let ((x1 p1) (x2 p2) ...) форма) = ((lambda (x1 x2 ...) форма) p1 p2 ...).
